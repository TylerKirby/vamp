#!/bin/bash

# vamp: Terminal-native Claude Code development environment
# Like a jazz vamp - keeps the rhythm while you improvise with Claude
#
# Usage: vamp [project-dir]
#        vamp status
#        vamp kill [session-name]
#        vamp list

set -e

VAMP_VERSION="0.4.0"

# Configuration - customize via ~/.config/vamp/config or env vars
FILE_VIEWER="${VAMP_FILE_VIEWER:-yazi}"
MONITOR_CMD="${VAMP_MONITOR:-htop}"
CLAUDE_CMD="${VAMP_CLAUDE_CMD:-claude}"
PROJECTS_DIR="${VAMP_PROJECTS_DIR:-$HOME/Projects}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m'

# Load config if exists
[ -f "$HOME/.config/vamp/config" ] && source "$HOME/.config/vamp/config"

# ============================================
# Subcommands
# ============================================

show_help() {
    echo -e "${CYAN}"
    cat << 'LOGO'
  ‚ô™‚ô´                            ‚ô´‚ô™
   __   __  __ _  _ __ ___   _ __
   \ \ / / / _` || '_ ` _ \ | '_ \
    \ V / | (_| || | | | | || |_) |
     \_/   \__,_||_| |_| |_|| .__/
                            |_|
LOGO
    echo -e "${NC}"
    cat << EOF
  ${DIM}v${VAMP_VERSION} - Terminal-native Claude Code environment${NC}

${YELLOW}USAGE:${NC}
    vamp [project-dir]     Start dev environment (default: current dir)
    vamp list              List active vamp sessions
    vamp attach <name>     Attach to existing session
    vamp kill <name>       Kill a session
    vamp killall           Kill all vamp sessions
    vamp init              Initialize project with beads + CLAUDE.md
    vamp setup             Install beads hooks for Claude Code + git
    vamp help              Show this help

${YELLOW}SWARM MODE:${NC}
    vamp swarm             Start swarm (auto-scales to task count)
    vamp swarm -w N        Start with exactly N workers (1-8)
    vamp swarm --status    Show status of swarm workers
    vamp swarm --cleanup   Remove worktrees (keep branches)
    vamp swarm --merge     Merge swarm branches to main
    vamp swarm --finish    Full cleanup (merge + delete branches)

${YELLOW}EXAMPLES:${NC}
    vamp                   Start in current directory
    vamp ~/Projects/app    Start in specific directory
    vamp attach app        Attach to 'vamp-app' session
    vamp swarm -w 2        Start swarm with 2 workers
    vamp list              Show all running sessions

${YELLOW}KEYBINDINGS:${NC}
    Ctrl-b + arrows        Navigate panes
    Ctrl-b + z             Zoom pane (toggle fullscreen)
    Ctrl-b + d             Detach (session keeps running)
    Ctrl-b + 0             Main window
    Ctrl-b + 1             Beads viewer window
    Ctrl-b + 2             Swarm window (if active)

${YELLOW}MOUSE:${NC}
    Scroll wheel           Scroll pane content
    Click pane             Select pane
    Drag border            Resize pane

${YELLOW}CONFIG:${NC}
    ~/.config/vamp/config

EOF
}

list_sessions() {
    echo -e "${CYAN}Active vamp sessions:${NC}"
    local sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null | grep "^vamp-" || true)
    if [ -z "$sessions" ]; then
        echo -e "${DIM}  No active sessions${NC}"
    else
        echo "$sessions" | while read -r session; do
            local project="${session#vamp-}"
            local windows=$(tmux list-windows -t "$session" -F '#{window_name}' 2>/dev/null | tr '\n' ' ')
            echo -e "  ${GREEN}‚óè${NC} $project ${DIM}[$windows]${NC}"
        done
    fi
}

attach_session() {
    local name="$1"
    if [ -z "$name" ]; then
        echo -e "${RED}Usage: vamp attach <session-name>${NC}"
        list_sessions
        return 1
    fi
    
    local session="vamp-$name"
    if tmux has-session -t "$session" 2>/dev/null; then
        tmux attach-session -t "$session"
    else
        echo -e "${RED}Session '$session' not found${NC}"
        list_sessions
        return 1
    fi
}

kill_session() {
    local name="$1"
    if [ -z "$name" ]; then
        echo -e "${RED}Usage: vamp kill <session-name>${NC}"
        list_sessions
        return 1
    fi
    
    local session="vamp-$name"
    if tmux kill-session -t "$session" 2>/dev/null; then
        echo -e "${GREEN}Killed session: $session${NC}"
    else
        echo -e "${RED}Session '$session' not found${NC}"
    fi
}

kill_all_sessions() {
    local sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null | grep "^vamp-" || true)
    if [ -z "$sessions" ]; then
        echo -e "${DIM}No vamp sessions to kill${NC}"
        return 0
    fi
    
    echo -e "${YELLOW}This will kill:${NC}"
    echo "$sessions" | sed 's/^/  /'
    read -p "Continue? [y/N] " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo "$sessions" | xargs -I {} tmux kill-session -t {}
        echo -e "${GREEN}All vamp sessions killed${NC}"
    fi
}

init_project() {
    local name=$(basename "$(pwd)")
    echo -e "${CYAN}Initializing project: $name${NC}"
    
    # Git
    if [ ! -d ".git" ]; then
        git init
        echo -e "  ${GREEN}‚úì${NC} Initialized git"
    fi
    
    # Beads
    if command -v bd &> /dev/null; then
        if [ ! -d ".beads" ] && [ ! -f ".beads.jsonl" ]; then
            bd init
            echo -e "  ${GREEN}‚úì${NC} Initialized beads"

            # CRITICAL: Configure dedicated sync branch to prevent conflicts with code commits
            # Without this, bd sync commits to main and can revert your code changes!
            bd config set sync.branch beads-sync 2>/dev/null
            echo -e "  ${GREEN}‚úì${NC} Configured beads sync branch (beads-sync)"
        else
            echo -e "  ${DIM}‚óã${NC} Beads already initialized"

            # Check if sync branch is configured, warn if not
            local sync_branch=$(bd config get sync.branch 2>/dev/null | grep -v "not set" || true)
            if [ -z "$sync_branch" ]; then
                echo -e "  ${YELLOW}‚ö†${NC} Beads sync branch not set!"
                echo -e "      Run: bd config set sync.branch beads-sync"
                echo -e "      This prevents bd sync from reverting your code commits."
            fi
        fi

        # Install git hooks
        bd hooks install 2>/dev/null && echo -e "  ${GREEN}‚úì${NC} Git hooks installed"

        # Check Claude integration
        if ! bd setup claude --check &>/dev/null; then
            echo -e "  ${YELLOW}?${NC} Claude Code hooks not installed"
            echo -e "      Run 'vamp setup' to install globally"
        fi
    else
        echo -e "  ${YELLOW}‚óã${NC} Beads not installed (brew tap steveyegge/beads && brew install beads)"
    fi
    
    # CLAUDE.md
    if [ ! -f "CLAUDE.md" ]; then
        cat > CLAUDE.md << EOF
# $name

## Project Overview
<!-- Brief description -->

## Tech Stack
<!-- Languages, frameworks, dependencies -->

## Development
- Task tracking: \`bd ready\` for available work
- Tests: \`<test command>\`

## Architecture
<!-- Key patterns and decisions -->

## Current Focus
<!-- Active work items -->
EOF
        echo -e "  ${GREEN}‚úì${NC} Created CLAUDE.md"
    else
        echo -e "  ${DIM}‚óã${NC} CLAUDE.md exists"
    fi
    
    # .gitignore
    if ! grep -q ".beads-cache" .gitignore 2>/dev/null; then
        echo -e "\n# Beads cache\n.beads-cache/" >> .gitignore
        echo -e "  ${GREEN}‚úì${NC} Updated .gitignore"
    fi
    
    echo -e "\n${GREEN}Ready! Run 'vamp' to start${NC}"
}

setup_beads() {
    echo -e "${CYAN}Setting up beads integration...${NC}"

    if ! command -v bd &> /dev/null; then
        echo -e "  ${RED}‚úó${NC} beads not installed"
        echo -e "    Install: brew tap steveyegge/beads && brew install beads"
        return 1
    fi

    # Install Claude Code hooks
    echo -e "${BLUE}Installing Claude Code hooks...${NC}"
    bd setup claude
    echo -e "  ${GREEN}‚úì${NC} Claude Code hooks installed"

    # Install git hooks if in a git repo
    if [ -d ".git" ]; then
        echo -e "${BLUE}Installing git hooks...${NC}"
        bd hooks install 2>/dev/null && echo -e "  ${GREEN}‚úì${NC} Git hooks installed"
    else
        echo -e "  ${DIM}‚óã${NC} Not a git repo, skipping git hooks"
    fi

    echo ""
    echo -e "${GREEN}Beads integration complete!${NC}"
    echo -e "  Restart Claude Code for hooks to take effect."
    echo -e "  Run 'bd setup claude --check' to verify."
}

# ============================================
# Swarm worktree management
# ============================================

SWARM_DIR=".vamp-workers"

# Create N git worktrees for swarm workers
# Each worktree gets its own branch: swarm/worker-1, swarm/worker-2, etc.
create_worktrees() {
    local count="${1:-4}"
    local project_dir="${2:-$(pwd)}"

    # Validate we're in a git repo
    if ! git -C "$project_dir" rev-parse --git-dir &>/dev/null; then
        echo -e "${RED}Error: Not a git repository${NC}"
        return 1
    fi

    # Check for uncommitted changes in main worktree
    if ! git -C "$project_dir" diff-index --quiet HEAD -- 2>/dev/null; then
        echo -e "${YELLOW}Warning: Uncommitted changes in main worktree${NC}"
        read -p "Continue anyway? [y/N] " confirm
        [[ ! "$confirm" =~ ^[Yy]$ ]] && return 1
    fi

    local worktree_base="$project_dir/$SWARM_DIR"
    local current_branch=$(git -C "$project_dir" branch --show-current)
    local base_ref="${current_branch:-HEAD}"

    # Check if worktrees already exist
    if [ -d "$worktree_base" ]; then
        local existing=$(ls -d "$worktree_base"/worker-* 2>/dev/null | wc -l | tr -d ' ')
        if [ "$existing" -gt 0 ]; then
            echo -e "${YELLOW}Swarm worktrees already exist ($existing workers)${NC}"
            echo "Run 'vamp swarm --cleanup' first or 'vamp swarm --status' to check"
            return 1
        fi
    fi

    mkdir -p "$worktree_base"

    # Add to .gitignore if not already
    if ! grep -q "^$SWARM_DIR" "$project_dir/.gitignore" 2>/dev/null; then
        echo -e "\n# Vamp swarm worktrees\n$SWARM_DIR/\n.vamp-worker\n.swarm-prompt" >> "$project_dir/.gitignore"
        echo -e "  ${GREEN}‚úì${NC} Added $SWARM_DIR/ and worker files to .gitignore"
    fi

    echo -e "${CYAN}Creating $count swarm worktrees from $base_ref...${NC}"

    for i in $(seq 1 "$count"); do
        local branch="swarm/worker-$i"
        local worktree="$worktree_base/worker-$i"

        # Create branch if it doesn't exist
        if ! git -C "$project_dir" show-ref --verify --quiet "refs/heads/$branch"; then
            git -C "$project_dir" branch "$branch" "$base_ref" 2>/dev/null
        fi

        # Create worktree
        if git -C "$project_dir" worktree add "$worktree" "$branch" 2>/dev/null; then
            echo -e "  ${GREEN}‚úì${NC} worker-$i ‚Üí $branch"

            # Create context file for Claude to reference
            cat > "$worktree/.vamp-worker" << EOF
# Vamp Swarm Worker Context
# This file helps Claude Code understand its isolated workspace

WORKER_NUMBER=$i
WORKER_BRANCH=$branch
WORKTREE_PATH=$worktree
MAIN_PROJECT_PATH=$project_dir

# IMPORTANT: All file operations must stay within WORKTREE_PATH
# NEVER edit files in MAIN_PROJECT_PATH
EOF

            # Ensure worker files and common artifacts are gitignored in worktree
            if ! grep -q "^\.vamp-worker" "$worktree/.gitignore" 2>/dev/null; then
                echo -e "\n# Vamp worker context\n.vamp-worker\n.swarm-prompt\n\n# Common test artifacts\n__pycache__/\n*.pyc\nnode_modules/" >> "$worktree/.gitignore"
            fi
        else
            echo -e "  ${RED}‚úó${NC} Failed to create worker-$i"
        fi
    done

    echo ""
    echo -e "${GREEN}Created $count worktrees in $SWARM_DIR/${NC}"
    list_worktrees "$project_dir"
}

# Remove all swarm worktrees and optionally their branches
cleanup_worktrees() {
    local project_dir="${1:-$(pwd)}"
    local delete_branches="${2:-}"  # pass "branches" to also delete branches
    local auto_confirm="${3:-}"     # pass "yes" to skip confirmation

    local worktree_base="$project_dir/$SWARM_DIR"

    if [ ! -d "$worktree_base" ]; then
        echo -e "${DIM}No swarm worktrees found${NC}"
        return 0
    fi

    # List what will be removed
    echo -e "${CYAN}Swarm worktrees to remove:${NC}"
    local worktrees=$(ls -d "$worktree_base"/worker-* 2>/dev/null)

    if [ -z "$worktrees" ]; then
        echo -e "  ${DIM}None found${NC}"
        return 0
    fi

    local branches_to_delete=()

    for wt in $worktrees; do
        local name=$(basename "$wt")
        local branch=$(git -C "$wt" branch --show-current 2>/dev/null || echo "unknown")

        # Check for uncommitted changes
        local status=""
        if ! git -C "$wt" diff-index --quiet HEAD -- 2>/dev/null; then
            status=" ${YELLOW}(uncommitted changes!)${NC}"
        fi

        echo -e "  $name ‚Üí $branch$status"
        branches_to_delete+=("$branch")
    done

    echo ""
    if [ "$auto_confirm" != "yes" ]; then
        read -p "Remove these worktrees? [y/N] " confirm
        [[ ! "$confirm" =~ ^[Yy]$ ]] && return 1
    fi

    # Remove worktrees
    for wt in $worktrees; do
        local name=$(basename "$wt")
        if git -C "$project_dir" worktree remove --force "$wt" 2>/dev/null; then
            echo -e "  ${GREEN}‚úì${NC} Removed $name"
        else
            # Fallback: manual removal
            rm -rf "$wt"
            git -C "$project_dir" worktree prune 2>/dev/null
            echo -e "  ${GREEN}‚úì${NC} Removed $name (force)"
        fi
    done

    # Clean up empty directory
    rmdir "$worktree_base" 2>/dev/null

    # Optionally delete branches
    if [ "$delete_branches" = "branches" ]; then
        echo ""
        echo -e "${CYAN}Deleting swarm branches...${NC}"
        for branch in "${branches_to_delete[@]}"; do
            if git -C "$project_dir" branch -d "$branch" 2>/dev/null; then
                echo -e "  ${GREEN}‚úì${NC} Deleted $branch"
            elif git -C "$project_dir" branch -D "$branch" 2>/dev/null; then
                echo -e "  ${YELLOW}‚úì${NC} Force deleted $branch (had unmerged changes)"
            else
                echo -e "  ${DIM}‚óã${NC} $branch (already deleted or doesn't exist)"
            fi
        done
    else
        echo ""
        echo -e "${DIM}Branches preserved. Delete with: vamp swarm --cleanup --delete-branches${NC}"
    fi

    # Prune worktree references
    git -C "$project_dir" worktree prune 2>/dev/null

    echo ""
    echo -e "${GREEN}Cleanup complete${NC}"
}

# List all swarm worktrees with their status
list_worktrees() {
    local project_dir="${1:-$(pwd)}"
    local worktree_base="$project_dir/$SWARM_DIR"

    if [ ! -d "$worktree_base" ]; then
        echo -e "${DIM}No swarm worktrees found${NC}"
        echo "Create with: vamp swarm [--workers=N]"
        return 0
    fi

    local worktrees=$(ls -d "$worktree_base"/worker-* 2>/dev/null)

    if [ -z "$worktrees" ]; then
        echo -e "${DIM}No swarm worktrees found${NC}"
        return 0
    fi

    echo -e "${CYAN}Swarm worktrees:${NC}"
    echo ""

    for wt in $worktrees; do
        local name=$(basename "$wt")
        local branch=$(git -C "$wt" branch --show-current 2>/dev/null || echo "detached")

        # Get commit info
        local commit=$(git -C "$wt" log -1 --format="%h %s" 2>/dev/null | head -c 50)

        # Check status
        local ahead=$(git -C "$wt" rev-list --count HEAD ^origin/"$branch" 2>/dev/null || echo "?")
        local changes=$(git -C "$wt" status --porcelain 2>/dev/null | wc -l | tr -d ' ')

        # Status indicators
        local status_icons=""
        [ "$changes" -gt 0 ] && status_icons+="${YELLOW}‚óè${NC} "
        [ "$ahead" != "?" ] && [ "$ahead" -gt 0 ] && status_icons+="${GREEN}‚Üë$ahead${NC} "

        echo -e "  ${GREEN}$name${NC} ‚Üí $branch"
        echo -e "    ${DIM}$commit${NC}"
        if [ -n "$status_icons" ]; then
            echo -e "    $status_icons"
        fi

        # Show beads in-progress if available
        if command -v bd &>/dev/null && [ -d "$wt/.beads" -o -f "$wt/.beads.jsonl" ]; then
            local in_progress=$(cd "$wt" && bd list --status in_progress --json 2>/dev/null | jq -r '.[0].title // empty' 2>/dev/null)
            if [ -n "$in_progress" ]; then
                echo -e "    ${CYAN}Working on:${NC} $in_progress"
            fi
        fi
        echo ""
    done
}

# Show summary of swarm worker branches and their changes
swarm_status() {
    local project_dir="${1:-$(pwd)}"
    local worktree_base="$project_dir/$SWARM_DIR"

    if [ ! -d "$worktree_base" ]; then
        echo -e "${DIM}No swarm worktrees found${NC}"
        return 0
    fi

    local worktrees=$(ls -d "$worktree_base"/worker-* 2>/dev/null)
    if [ -z "$worktrees" ]; then
        echo -e "${DIM}No swarm worktrees found${NC}"
        return 0
    fi

    local main_branch=$(git -C "$project_dir" branch --show-current)

    echo -e "${CYAN}Swarm Status${NC}"
    echo -e "${DIM}Base branch: $main_branch${NC}"
    echo ""

    for wt in $worktrees; do
        local name=$(basename "$wt")
        local branch=$(git -C "$wt" branch --show-current 2>/dev/null || echo "detached")

        # Get commit count ahead of main
        local ahead=$(git -C "$wt" rev-list --count "$main_branch".."$branch" 2>/dev/null || echo "0")

        # Get diff stats
        local stats=$(git -C "$wt" diff --stat "$main_branch".."$branch" 2>/dev/null | tail -1)

        # Check for uncommitted changes
        local dirty=""
        if ! git -C "$wt" diff-index --quiet HEAD -- 2>/dev/null; then
            dirty=" ${YELLOW}(uncommitted changes)${NC}"
        fi

        echo -e "${GREEN}$name${NC} ‚Üí $branch$dirty"
        if [ "$ahead" -gt 0 ]; then
            echo -e "  ${CYAN}$ahead commits ahead${NC}"
            if [ -n "$stats" ]; then
                echo -e "  ${DIM}$stats${NC}"
            fi
        else
            echo -e "  ${DIM}No changes${NC}"
        fi
        echo ""
    done
}

# Merge swarm branches back to main
swarm_merge() {
    local project_dir="${1:-$(pwd)}"
    local auto_merge="${2:-}"  # pass "auto" for non-interactive
    local worktree_base="$project_dir/$SWARM_DIR"

    if [ ! -d "$worktree_base" ]; then
        echo -e "${DIM}No swarm worktrees found${NC}"
        return 0
    fi

    local worktrees=$(ls -d "$worktree_base"/worker-* 2>/dev/null)
    if [ -z "$worktrees" ]; then
        echo -e "${DIM}No swarm worktrees found${NC}"
        return 0
    fi

    local main_branch=$(git -C "$project_dir" branch --show-current)

    # First, show status
    swarm_status "$project_dir"

    # Collect branches with changes
    local branches_to_merge=()
    for wt in $worktrees; do
        local branch=$(git -C "$wt" branch --show-current 2>/dev/null)
        local ahead=$(git -C "$wt" rev-list --count "$main_branch".."$branch" 2>/dev/null || echo "0")

        if [ "$ahead" -gt 0 ]; then
            # Check for uncommitted or untracked files
            local wt_dirty=$(git -C "$wt" status --porcelain 2>/dev/null | grep -v "^?? __pycache__" | grep -v "^?? .*\.pyc" | grep -v "^?? \.swarm-prompt")
            if [ -n "$wt_dirty" ]; then
                echo -e "${YELLOW}Warning: $(basename $wt) has uncommitted changes${NC}"
                echo "$wt_dirty" | head -5 | sed 's/^/  /'
                echo "  Commit or stash changes before merging"
                continue
            fi
            branches_to_merge+=("$branch")
        fi
    done

    if [ ${#branches_to_merge[@]} -eq 0 ]; then
        echo -e "${DIM}No branches with changes to merge${NC}"
        return 0
    fi

    echo -e "${CYAN}Branches to merge:${NC}"
    for branch in "${branches_to_merge[@]}"; do
        echo "  - $branch"
    done
    echo ""

    if [ "$auto_merge" != "auto" ]; then
        read -p "Merge these branches into $main_branch? [y/N] " confirm
        [[ ! "$confirm" =~ ^[Yy]$ ]] && return 1
    fi

    # Ensure main worktree is clean (check both staged/unstaged changes AND untracked files)
    local dirty_files=$(git -C "$project_dir" status --porcelain 2>/dev/null)
    if [ -n "$dirty_files" ]; then
        echo -e "${RED}Error: Main worktree has uncommitted or untracked files${NC}"
        echo "$dirty_files" | head -10 | sed 's/^/  /'
        echo ""
        echo "Commit or stash changes before merging"
        return 1
    fi

    # Merge each branch
    local merged=0
    local failed=0

    for branch in "${branches_to_merge[@]}"; do
        echo ""
        echo -e "${CYAN}Merging $branch...${NC}"

        if git -C "$project_dir" merge --no-edit "$branch" 2>/dev/null; then
            echo -e "  ${GREEN}‚úì${NC} Merged $branch"
            ((merged++))
        else
            echo -e "  ${RED}‚úó${NC} Merge conflict in $branch"
            echo ""
            echo -e "${YELLOW}Conflict detected. Options:${NC}"
            echo "  1. Resolve manually: cd $project_dir && git status"
            echo "  2. Abort merge: git merge --abort"
            echo "  3. Continue after resolving: git commit"
            echo ""

            if [ "$auto_merge" != "auto" ]; then
                read -p "Abort this merge and continue with others? [y/N] " abort
                if [[ "$abort" =~ ^[Yy]$ ]]; then
                    git -C "$project_dir" merge --abort 2>/dev/null
                    ((failed++))
                else
                    echo "Stopping merge process. Resolve conflict and run 'vamp swarm --merge' again."
                    return 1
                fi
            else
                git -C "$project_dir" merge --abort 2>/dev/null
                ((failed++))
            fi
        fi
    done

    echo ""
    echo -e "${GREEN}Merge complete:${NC} $merged succeeded, $failed failed"

    if [ "$merged" -gt 0 ]; then
        echo ""
        echo -e "${DIM}Next steps:${NC}"
        echo "  1. Review merged changes: git log --oneline -$merged"
        echo "  2. Push to remote: git push"
        echo "  3. Clean up: vamp swarm --cleanup"
    fi
}

# Full cleanup workflow: merge, cleanup worktrees, delete branches
swarm_finish() {
    local project_dir="${1:-$(pwd)}"
    local delete_branches="${2:-}"
    local close_window="${3:-}"
    local auto_confirm="${4:-}"

    echo -e "${CYAN}‚ïê‚ïê‚ïê Swarm Finish Workflow ‚ïê‚ïê‚ïê${NC}"
    echo ""

    # Show status first
    swarm_status "$project_dir"

    # Ask about merging
    local worktrees=$(ls -d "$project_dir/$SWARM_DIR"/worker-* 2>/dev/null)
    if [ -n "$worktrees" ]; then
        if [ "$auto_confirm" = "yes" ]; then
            # Auto-merge when --yes is specified
            swarm_merge "$project_dir" "auto"
        else
            read -p "Merge swarm branches before cleanup? [Y/n] " merge_first
            if [[ ! "$merge_first" =~ ^[Nn]$ ]]; then
                swarm_merge "$project_dir"
            fi
        fi
    fi

    echo ""

    # Cleanup worktrees
    cleanup_worktrees "$project_dir" "$delete_branches" "$auto_confirm"

    # Close swarm window if requested
    if [ "$close_window" = "yes" ]; then
        local project_name=$(basename "$project_dir")
        local session_name="vamp-$(echo "$project_name" | tr '.:' '-')"

        if tmux has-session -t "$session_name" 2>/dev/null; then
            if tmux list-windows -t "$session_name" -F '#{window_name}' | grep -q "^swarm$"; then
                echo ""
                echo -e "${CYAN}Closing swarm window...${NC}"
                tmux kill-window -t "$session_name:swarm"
                echo -e "  ${GREEN}‚úì${NC} Swarm window closed"
            fi
        fi
    fi
}

# Create tmux window with N panes in a grid layout for swarm workers
# Creates a balanced grid based on worker count
create_swarm_window() {
    local session="$1"
    local count="${2:-4}"
    local project_dir="${3:-$(pwd)}"

    # Calculate grid dimensions
    local cols rows
    case "$count" in
        1) cols=1; rows=1 ;;
        2) cols=2; rows=1 ;;
        3|4) cols=2; rows=2 ;;
        5|6) cols=3; rows=2 ;;
        7|8) cols=4; rows=2 ;;
        *) cols=4; rows=$(( (count + 3) / 4 )) ;;
    esac

    # Create new window
    tmux new-window -t "$session" -n "swarm" -c "$project_dir"

    # For single pane, we're done
    if [ "$count" -eq 1 ]; then
        return 0
    fi

    # Create the grid layout
    # First, create all the columns by splitting horizontally
    local pane_width=$((100 / cols))

    # Split into columns (from right to left to maintain indices)
    for ((c = cols - 1; c >= 1; c--)); do
        local split_percent=$((100 - (c * pane_width)))
        tmux split-window -t "$session:swarm.0" -h -p "$split_percent" -c "$project_dir"
    done

    # Now split each column vertically into rows
    if [ "$rows" -gt 1 ]; then
        local row_height=$((100 / rows))
        for ((c = 0; c < cols; c++)); do
            # Calculate pane index for this column (columns are created left to right)
            local pane_idx=$c

            for ((r = rows - 1; r >= 1; r--)); do
                local split_percent=$((100 - (r * row_height)))
                tmux split-window -t "$session:swarm.$pane_idx" -v -p "$split_percent" -c "$project_dir"
            done
        done
    fi

    # Balance all panes to make them equal size
    tmux select-layout -t "$session:swarm" tiled

    # Select first pane
    tmux select-pane -t "$session:swarm.0"
}

# Initialize each swarm pane with a worker
# Each worker: cd to worktree, run bd ready, start claude with context
init_swarm_workers() {
    local session="$1"
    local count="${2:-4}"
    local project_dir="${3:-$(pwd)}"
    local task_ids="$4"  # Newline-separated list of task IDs
    local worktree_base="$project_dir/$SWARM_DIR"

    # Convert task IDs to array
    local -a tasks=()
    if [ -n "$task_ids" ]; then
        while IFS= read -r line; do
            [ -n "$line" ] && tasks+=("$line")
        done <<< "$task_ids"
    fi

    for ((i = 1; i <= count; i++)); do
        local pane_idx=$((i - 1))
        local worktree="$worktree_base/worker-$i"
        local branch="swarm/worker-$i"

        # Get assigned task for this worker (0-indexed)
        local assigned_task="${tasks[$((i-1))]:-}"

        if [ -d "$worktree" ]; then
            # Change to worktree directory
            tmux send-keys -t "$session:swarm.$pane_idx" "cd '$worktree' && clear" Enter

            # Show worker info and assigned task
            if [ -n "$assigned_task" ]; then
                tmux send-keys -t "$session:swarm.$pane_idx" "echo 'üêù Worker $i ($branch) ‚Üí Task: $assigned_task'" Enter
            else
                tmux send-keys -t "$session:swarm.$pane_idx" "echo 'üêù Worker $i ($branch) ‚Üí No task assigned'" Enter
            fi

            # Show the assigned task details if available
            if [ -n "$assigned_task" ] && command -v bd &>/dev/null; then
                tmux send-keys -t "$session:swarm.$pane_idx" "bd show $assigned_task" Enter
            fi

            # Write instructions with specific task assignment
            if [ -n "$assigned_task" ]; then
                cat > "$worktree/.swarm-prompt" << PROMPT_EOF
SWARM WORKER $i - Branch: $branch
YOUR ASSIGNED TASK: $assigned_task

Worktree: $worktree (ONLY edit files here)
Forbidden: $project_dir (DO NOT touch)

WORKFLOW:
1. Claim YOUR task: bd update $assigned_task --status=in_progress
2. Implement the task (see bd show output above)
3. Commit: git add . && git commit -m "description"
4. Close: bd close $assigned_task
PROMPT_EOF
                tmux send-keys -t "$session:swarm.$pane_idx" "$CLAUDE_CMD 'You are assigned task $assigned_task. Read .swarm-prompt then claim and implement your assigned task.'" Enter
            else
                # No task assigned - worker will be idle
                cat > "$worktree/.swarm-prompt" << PROMPT_EOF
SWARM WORKER $i - Branch: $branch
NO TASK ASSIGNED - All tasks claimed by other workers.

You can either:
1. Wait for new tasks: bd ready
2. Help with code review
3. Exit: /exit
PROMPT_EOF
                tmux send-keys -t "$session:swarm.$pane_idx" "$CLAUDE_CMD 'No task assigned to you. Read .swarm-prompt for options.'" Enter
            fi
        else
            tmux send-keys -t "$session:swarm.$pane_idx" "echo 'Worktree not found: $worktree'" Enter
        fi
    done
}

# ============================================
# Beads viewer script (runs in window)
# ============================================

create_beads_viewer() {
    cat << 'BEADS_SCRIPT'
#!/bin/bash
# Beads issue tracker viewer

# Colors
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
RED='\033[0;31m'
DIM='\033[2m'
NC='\033[0m'

while true; do
    clear
    echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${CYAN}              üìø Beads Issue Tracker            ${NC}"
    echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""

    # Check if beads is available
    if ! command -v bd &> /dev/null; then
        echo -e "${RED}Beads not installed${NC}"
        echo "Install: brew tap steveyegge/beads && brew install beads"
        echo ""
        echo -e "${DIM}30s refresh | Ctrl-C exit${NC}"
        sleep 30
        continue
    fi

    # Check if beads is initialized
    if [ ! -d ".beads" ] && [ ! -f ".beads.jsonl" ]; then
        echo -e "${DIM}Beads not initialized in this project${NC}"
        echo "Run: bd init"
        echo ""
        echo -e "${DIM}30s refresh | Ctrl-C exit${NC}"
        sleep 30
        continue
    fi

    # ========== READY ISSUES ==========
    echo -e "${GREEN}‚ñ∂ READY${NC} ${DIM}(no blockers)${NC}"
    READY_OUTPUT=$(bd ready 2>/dev/null)
    if [ -n "$READY_OUTPUT" ]; then
        echo "$READY_OUTPUT" | head -10
        READY_COUNT=$(echo "$READY_OUTPUT" | wc -l | tr -d ' ')
        if [ "$READY_COUNT" -gt 10 ]; then
            echo -e "${DIM}  ... and $((READY_COUNT - 10)) more${NC}"
        fi
    else
        echo -e "  ${DIM}None${NC}"
    fi
    echo ""

    # ========== IN PROGRESS ==========
    echo -e "${YELLOW}‚óâ IN PROGRESS${NC}"
    IP_OUTPUT=$(bd list --status in_progress 2>/dev/null)
    if [ -n "$IP_OUTPUT" ]; then
        echo "$IP_OUTPUT" | head -10
    else
        echo -e "  ${DIM}None${NC}"
    fi
    echo ""

    # ========== BLOCKED ==========
    echo -e "${RED}‚äò BLOCKED${NC}"
    BLOCKED_OUTPUT=$(bd list --status blocked 2>/dev/null)
    if [ -n "$BLOCKED_OUTPUT" ]; then
        echo "$BLOCKED_OUTPUT" | head -10
    else
        echo -e "  ${DIM}None${NC}"
    fi
    echo ""

    # ========== STATS ==========
    echo -e "${CYAN}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    STATS=$(bd stats 2>/dev/null | head -5)
    if [ -n "$STATS" ]; then
        echo "$STATS"
    fi
    echo ""

    # ========== COMMANDS ==========
    echo -e "${DIM}Commands: bd ready | bd show <id> | bd create | bd close <id>${NC}"
    echo -e "${DIM}30s refresh | Ctrl-C exit${NC}"

    sleep 30
done
BEADS_SCRIPT
}

# ============================================
# Claude monitor script (runs in pane)
# ============================================

create_claude_monitor() {
    cat << 'MONITOR_SCRIPT'
#!/bin/bash
# Claude Code usage monitor - mirrors /usage data

CLAUDE_DIR="$HOME/.claude"
STATS_FILE="$CLAUDE_DIR/stats-cache.json"

# Colors
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
DIM='\033[2m'
NC='\033[0m'

# Format large numbers (1234567 -> 1.23M)
format_tokens() {
    local n=$1
    if [ -z "$n" ] || [ "$n" = "null" ]; then
        echo "0"
    elif [ "$n" -ge 1000000 ] 2>/dev/null; then
        awk "BEGIN {printf \"%.1fM\", $n/1000000}"
    elif [ "$n" -ge 1000 ] 2>/dev/null; then
        awk "BEGIN {printf \"%.1fK\", $n/1000}"
    else
        echo "$n"
    fi
}

# Draw hourly activity sparkline
draw_sparkline() {
    local hours="$1"
    local chars=(" " "‚ñÅ" "‚ñÇ" "‚ñÉ" "‚ñÑ" "‚ñÖ" "‚ñÜ" "‚ñá" "‚ñà")
    local max=$(echo "$hours" | jq -r 'to_entries | map(.value) | max // 1')

    for h in $(seq 0 23); do
        local count=$(echo "$hours" | jq -r ".[\"$h\"] // 0")
        local idx=0
        if [ "$max" -gt 0 ] && [ "$count" -gt 0 ]; then
            idx=$(awk "BEGIN {printf \"%d\", ($count * 8 / $max)}")
            [ $idx -gt 8 ] && idx=8
        fi
        printf "${chars[$idx]}"
    done
}

while true; do
    clear
    echo -e "${CYAN}‚ïê‚ïê‚ïê Claude Usage ‚ïê‚ïê‚ïê${NC}"
    echo ""

    # Check if stats file exists
    if [ ! -f "$STATS_FILE" ]; then
        echo -e "${DIM}No usage stats yet.${NC}"
        echo "Use Claude Code to generate stats."
        echo ""
        echo -e "${DIM}30s refresh | Ctrl-C exit${NC}"
        sleep 30
        continue
    fi

    # Check jq availability
    if ! command -v jq &> /dev/null; then
        echo -e "${YELLOW}jq required${NC}"
        echo "Install: brew install jq"
        sleep 30
        continue
    fi

    # Parse stats
    STATS=$(cat "$STATS_FILE")
    TODAY=$(date +%Y-%m-%d)

    # ========== TODAY'S STATS ==========
    echo -e "${YELLOW}TODAY${NC} ${DIM}($TODAY)${NC}"

    TODAY_DATA=$(echo "$STATS" | jq -r --arg d "$TODAY" '.dailyActivity[] | select(.date == $d)' 2>/dev/null)
    if [ -n "$TODAY_DATA" ]; then
        MSGS=$(echo "$TODAY_DATA" | jq -r '.messageCount // 0')
        SESSIONS=$(echo "$TODAY_DATA" | jq -r '.sessionCount // 0')
        TOOLS=$(echo "$TODAY_DATA" | jq -r '.toolCallCount // 0')
        printf "  Messages: %s  Sessions: %s\n" "$MSGS" "$SESSIONS"
        printf "  Tool Calls: %s\n" "$TOOLS"
    else
        echo -e "  ${DIM}No activity today${NC}"
    fi

    echo ""

    # ========== TOKEN USAGE BY MODEL ==========
    echo -e "${YELLOW}TOKENS${NC} ${DIM}(All Time)${NC}"

    # Get all model names
    MODELS=$(echo "$STATS" | jq -r '.modelUsage | keys[]' 2>/dev/null)

    for model in $MODELS; do
        # Extract short name (Opus 4.5 or Sonnet 4.5)
        SHORT_NAME=$(echo "$model" | sed 's/claude-//' | sed 's/-[0-9]*$//' | sed 's/-/ /g' | awk '{print toupper(substr($1,1,1)) substr($1,2) " " $2 "." $3}')

        IN=$(echo "$STATS" | jq -r ".modelUsage[\"$model\"].inputTokens // 0")
        OUT=$(echo "$STATS" | jq -r ".modelUsage[\"$model\"].outputTokens // 0")
        CACHE_R=$(echo "$STATS" | jq -r ".modelUsage[\"$model\"].cacheReadInputTokens // 0")
        CACHE_W=$(echo "$STATS" | jq -r ".modelUsage[\"$model\"].cacheCreationInputTokens // 0")

        echo -e "  ${GREEN}$SHORT_NAME${NC}"
        printf "    In: %s  Out: %s\n" "$(format_tokens $IN)" "$(format_tokens $OUT)"
        printf "    Cache: %s read, %s write\n" "$(format_tokens $CACHE_R)" "$(format_tokens $CACHE_W)"
    done

    echo ""

    # ========== LIFETIME STATS ==========
    echo -e "${YELLOW}LIFETIME${NC}"
    TOTAL_SESSIONS=$(echo "$STATS" | jq -r '.totalSessions // 0')
    TOTAL_MSGS=$(echo "$STATS" | jq -r '.totalMessages // 0')
    printf "  Sessions: %s  Messages: %s\n" "$TOTAL_SESSIONS" "$(format_tokens $TOTAL_MSGS)"

    echo ""

    # ========== ACTIVITY SPARKLINE ==========
    echo -e "${YELLOW}ACTIVITY${NC} ${DIM}(by hour)${NC}"
    HOURS=$(echo "$STATS" | jq -r '.hourCounts // {}')
    if [ "$HOURS" != "{}" ] && [ "$HOURS" != "null" ]; then
        printf "  "
        draw_sparkline "$HOURS"
        echo ""
        echo -e "  ${DIM}^0    ^6   ^12   ^18  ^23${NC}"
    else
        echo -e "  ${DIM}No hourly data${NC}"
    fi

    echo ""

    # ========== BEADS STATUS ==========
    echo -e "${YELLOW}BEADS${NC}"
    if command -v bd &> /dev/null && [ -d ".beads" -o -f ".beads.jsonl" ]; then
        READY=$(bd ready --json 2>/dev/null | jq -r 'length' 2>/dev/null || echo "?")
        IN_PROG=$(bd list --status in_progress --json 2>/dev/null | jq -r 'length' 2>/dev/null || echo "?")
        BLOCKED=$(bd list --status blocked --json 2>/dev/null | jq -r 'length' 2>/dev/null || echo "?")
        printf "  Ready: %s  In Progress: %s  Blocked: %s\n" "$READY" "$IN_PROG" "$BLOCKED"
    else
        echo -e "  ${DIM}Not initialized${NC}"
    fi

    echo ""
    echo -e "${DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    echo -e "${DIM}30s refresh | Ctrl-C exit${NC}"

    sleep 30
done
MONITOR_SCRIPT
}

# ============================================
# Main session launcher
# ============================================

start_session() {
    local PROJECT_DIR="${1:-$(pwd)}"
    PROJECT_DIR=$(cd "$PROJECT_DIR" 2>/dev/null && pwd) || {
        echo -e "${RED}Directory not found: $1${NC}"
        exit 1
    }
    
    local PROJECT_NAME=$(basename "$PROJECT_DIR")
    local SESSION_NAME="vamp-$(echo "$PROJECT_NAME" | tr '.:' '-')"
    
    echo -e "${CYAN}  ‚ô™‚ô´ vamp ‚ô´‚ô™${NC} ${DIM}v${VAMP_VERSION}${NC}"
    echo -e "${GREEN}  Project:${NC} $PROJECT_NAME"
    echo -e "${GREEN}  Path:${NC} $PROJECT_DIR"
    
    # Check if session exists
    if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        echo -e "${YELLOW}Session exists. Attaching...${NC}"
        tmux attach-session -t "$SESSION_NAME"
        return 0
    fi
    
    # Validate tools
    if ! command -v tmux &> /dev/null; then
        echo -e "${RED}tmux not found. Install with: brew install tmux${NC}"
        exit 1
    fi
    
    # Fallbacks for optional tools
    command -v "$FILE_VIEWER" &> /dev/null || FILE_VIEWER="ls -la && echo 'Install yazi: brew install yazi'"
    command -v "$MONITOR_CMD" &> /dev/null || MONITOR_CMD="top"
    
    # Check beads status
    local BEADS_INIT=""
    [ -d "$PROJECT_DIR/.beads" ] || [ -f "$PROJECT_DIR/.beads.jsonl" ] && BEADS_INIT="yes"
    
    # Create monitor script
    local MONITOR_SCRIPT="/tmp/vamp-claude-monitor-$$.sh"
    create_claude_monitor > "$MONITOR_SCRIPT"
    chmod +x "$MONITOR_SCRIPT"
    
    # ============================================
    # Create tmux session
    # ============================================
    # Layout:
    # +-------------------+--------+
    # |                   |        |
    # |   Claude Code     | Files  |
    # |                   |        |
    # +-------------------+--------+
    # |  Shell/Beads      | Monitor|
    # +-------------------+--------+
    
    tmux new-session -d -s "$SESSION_NAME" -c "$PROJECT_DIR" -x "$(tput cols)" -y "$(tput lines)"
    tmux rename-window -t "$SESSION_NAME:0" "main"

    # Enable mouse support (scoped to this session only)
    tmux set-option -t "$SESSION_NAME" mouse on
    tmux set-option -t "$SESSION_NAME" focus-events on

    # Status bar with vamp version
    tmux set-option -t "$SESSION_NAME" status-right "vamp v${VAMP_VERSION} | %H:%M"
    tmux set-option -t "$SESSION_NAME" status-style "bg=colour236,fg=colour248"

    # Split: left 70% | right 30%
    tmux split-window -t "$SESSION_NAME:0" -h -p 30 -c "$PROJECT_DIR"
    
    # Split right pane: top files | bottom monitor
    tmux split-window -t "$SESSION_NAME:0.1" -v -p 40 -c "$PROJECT_DIR"
    
    # Split left pane: top claude | bottom shell
    tmux select-pane -t "$SESSION_NAME:0.0"
    tmux split-window -t "$SESSION_NAME:0.0" -v -p 25 -c "$PROJECT_DIR"
    
    # Pane 0: Claude Code
    tmux send-keys -t "$SESSION_NAME:0.0" "cd '$PROJECT_DIR' && clear && echo 'üéπ Claude Code' && $CLAUDE_CMD" Enter
    
    # Pane 1: Shell with beads
    tmux send-keys -t "$SESSION_NAME:0.1" "cd '$PROJECT_DIR' && clear" Enter
    if [ -n "$BEADS_INIT" ]; then
        tmux send-keys -t "$SESSION_NAME:0.1" "echo 'üìø Beads' && bd ready" Enter
    else
        tmux send-keys -t "$SESSION_NAME:0.1" "echo 'üíª Shell (bd init for beads)'" Enter
    fi
    
    # Pane 2: File viewer
    tmux send-keys -t "$SESSION_NAME:0.2" "cd '$PROJECT_DIR' && $FILE_VIEWER" Enter

    # Split pane 3 (monitor area) into htop + claude usage
    tmux split-window -t "$SESSION_NAME:0.3" -v -p 50 -c "$PROJECT_DIR"

    # Pane 3: System monitor (htop)
    tmux send-keys -t "$SESSION_NAME:0.3" "$MONITOR_CMD" Enter

    # Pane 4: Claude usage checker
    tmux send-keys -t "$SESSION_NAME:0.4" "cd '$PROJECT_DIR' && clear && echo 'üìä Claude Usage (run /usage to check limits)' && $CLAUDE_CMD" Enter

    # Focus Claude pane
    tmux select-pane -t "$SESSION_NAME:0.0"

    # Window 1: Beads viewer (prefer bv if installed, fallback to simple script)
    tmux new-window -t "$SESSION_NAME" -n "beads" -c "$PROJECT_DIR"
    if command -v bv &> /dev/null; then
        tmux send-keys -t "$SESSION_NAME:beads" "bv" Enter
    else
        local BEADS_SCRIPT="/tmp/vamp-beads-viewer-$$.sh"
        create_beads_viewer > "$BEADS_SCRIPT"
        chmod +x "$BEADS_SCRIPT"
        tmux send-keys -t "$SESSION_NAME:beads" "$BEADS_SCRIPT" Enter
    fi

    # Back to main
    tmux select-window -t "$SESSION_NAME:0"

    echo ""
    echo -e "${CYAN}Keybindings:${NC}"
    echo "  Ctrl-b + arrows  Navigate panes"
    echo "  Ctrl-b + z       Zoom pane"
    echo "  Ctrl-b + d       Detach"
    echo "  Ctrl-b + 0/1     Switch windows"
    echo ""
    echo -e "${CYAN}Mouse:${NC}"
    echo "  Scroll           Scroll content"
    echo "  Click            Select pane"
    echo "  Drag border      Resize pane"
    echo ""

    tmux attach-session -t "$SESSION_NAME"
}

# ============================================
# Swarm session launcher
# ============================================

start_swarm() {
    local PROJECT_DIR="$(pwd)"
    local WORKER_COUNT=4
    local EXPLICIT_WORKERS=""  # Track if -w was explicitly provided
    local ACTION=""
    local CLOSE_WINDOW=""
    local AUTO_CONFIRM=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -w|--workers)
                WORKER_COUNT="$2"
                EXPLICIT_WORKERS="yes"
                shift 2
                ;;
            --workers=*)
                WORKER_COUNT="${1#*=}"
                EXPLICIT_WORKERS="yes"
                shift
                ;;
            --status)
                ACTION="status"
                shift
                ;;
            --cleanup)
                ACTION="cleanup"
                shift
                ;;
            --finish)
                ACTION="finish"
                shift
                ;;
            --merge)
                ACTION="merge"
                shift
                ;;
            --delete-branches)
                ACTION="finish-branches"
                shift
                ;;
            --close)
                CLOSE_WINDOW="yes"
                shift
                ;;
            -y|--yes)
                AUTO_CONFIRM="yes"
                shift
                ;;
            -h|--help)
                echo -e "${CYAN}  ‚ô™‚ô´ vamp swarm üêù ‚ô´‚ô™${NC}"
                echo -e "  ${DIM}Multi-instance Claude Code with git worktrees${NC}"
                echo ""
                echo -e "${YELLOW}USAGE:${NC}"
                echo "    vamp swarm                 Start swarm (auto-scales to available tasks)"
                echo "    vamp swarm -w N            Start with exactly N workers (1-8)"
                echo "    vamp swarm --status        Show swarm status"
                echo "    vamp swarm --cleanup       Cleanup worktrees (keep branches)"
                echo "    vamp swarm --merge         Merge swarm branches to main"
                echo "    vamp swarm --finish        Merge + cleanup (keep window open)"
                echo "    vamp swarm --finish --close  Merge + cleanup + close swarm window"
                echo ""
                echo -e "${YELLOW}OPTIONS:${NC}"
                echo "    -w, --workers N            Set exact worker count (disables auto-scaling)"
                echo "    -y, --yes                  Skip confirmation prompts (non-interactive)"
                echo ""
                echo -e "${YELLOW}AUTO-SCALING:${NC}"
                echo "    By default, swarm auto-scales workers to match available beads tasks."
                echo "    Use -w to override with a specific count (warns if workers > tasks)."
                echo ""
                echo -e "${YELLOW}WORKFLOW:${NC}"
                echo "    1. vamp swarm              Create worktrees, start workers"
                echo "    2. Workers pick issues     Each runs 'bd ready' and claims work"
                echo "    3. vamp swarm --status     Check progress"
                echo "    4. vamp swarm --finish     Merge and cleanup when done"
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done

    # Auto-scale workers and get task assignments (only when starting swarm, not for other actions)
    local TASK_IDS=""
    if [ -z "$ACTION" ] && command -v bd &>/dev/null && command -v jq &>/dev/null; then
        local ready_json=$(bd ready --json 2>/dev/null || echo "[]")
        local ready_count=$(echo "$ready_json" | jq length 2>/dev/null || echo "0")

        # Extract task IDs for assignment (one per line)
        TASK_IDS=$(echo "$ready_json" | jq -r '.[].id' 2>/dev/null || echo "")

        if [ -z "$EXPLICIT_WORKERS" ]; then
            # Auto-scale: min(default, ready_count)
            if [ "$ready_count" -gt 0 ]; then
                if [ "$ready_count" -lt "$WORKER_COUNT" ]; then
                    WORKER_COUNT="$ready_count"
                    echo -e "${CYAN}Detected $ready_count task(s), scaling to $WORKER_COUNT worker(s)${NC}"
                else
                    echo -e "${CYAN}Detected $ready_count task(s), using $WORKER_COUNT worker(s)${NC}"
                fi
            else
                echo -e "${DIM}No beads tasks found, using default $WORKER_COUNT worker(s)${NC}"
            fi
        else
            # Warn if user requested more workers than tasks
            if [ "$ready_count" -gt 0 ] && [ "$WORKER_COUNT" -gt "$ready_count" ]; then
                echo -e "${YELLOW}Warning: $WORKER_COUNT workers requested but only $ready_count task(s) available${NC}"
                echo -e "${DIM}Some workers may be idle. Consider: vamp swarm -w $ready_count${NC}"
            elif [ "$ready_count" -gt 0 ]; then
                echo -e "${CYAN}Detected $ready_count task(s)${NC}"
            fi
        fi
    fi

    # Validate worker count
    if ! [[ "$WORKER_COUNT" =~ ^[0-9]+$ ]] || [ "$WORKER_COUNT" -lt 1 ] || [ "$WORKER_COUNT" -gt 8 ]; then
        echo -e "${RED}Error: Worker count must be 1-8${NC}"
        return 1
    fi

    # Handle actions
    case "$ACTION" in
        status)
            swarm_status "$PROJECT_DIR"
            list_worktrees "$PROJECT_DIR"
            return 0
            ;;
        cleanup)
            cleanup_worktrees "$PROJECT_DIR" "" "$AUTO_CONFIRM"
            return 0
            ;;
        merge)
            if [ "$AUTO_CONFIRM" = "yes" ]; then
                swarm_merge "$PROJECT_DIR" "auto"
            else
                swarm_merge "$PROJECT_DIR"
            fi
            return 0
            ;;
        finish)
            swarm_finish "$PROJECT_DIR" "" "$CLOSE_WINDOW" "$AUTO_CONFIRM"
            return 0
            ;;
        finish-branches)
            swarm_finish "$PROJECT_DIR" "branches" "$CLOSE_WINDOW" "$AUTO_CONFIRM"
            return 0
            ;;
    esac

    # Start swarm session
    local PROJECT_NAME=$(basename "$PROJECT_DIR")
    local SESSION_NAME="vamp-$(echo "$PROJECT_NAME" | tr '.:' '-')"

    echo -e "${CYAN}  ‚ô™‚ô´ vamp swarm üêù ‚ô´‚ô™${NC} ${DIM}v${VAMP_VERSION}${NC}"
    echo -e "${GREEN}  Project:${NC} $PROJECT_NAME"
    echo -e "${GREEN}  Workers:${NC} $WORKER_COUNT"
    echo ""

    # Check if regular session exists
    if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        # Check if swarm window already exists
        if tmux list-windows -t "$SESSION_NAME" -F '#{window_name}' | grep -q "^swarm$"; then
            echo -e "${YELLOW}Swarm window exists. Attaching...${NC}"
            tmux select-window -t "$SESSION_NAME:swarm"
            tmux attach-session -t "$SESSION_NAME"
            return 0
        fi
    else
        echo -e "${YELLOW}No vamp session. Creating one first...${NC}"
        # Create base session (detached)
        start_session "$PROJECT_DIR" &
        sleep 2
    fi

    # Validate we're in a git repo
    if ! git rev-parse --git-dir &>/dev/null; then
        echo -e "${RED}Error: Not a git repository${NC}"
        return 1
    fi

    # Create worktrees
    echo -e "${CYAN}Creating worktrees...${NC}"
    create_worktrees "$WORKER_COUNT" "$PROJECT_DIR"

    if [ $? -ne 0 ]; then
        echo -e "${RED}Failed to create worktrees${NC}"
        return 1
    fi

    # Create swarm window
    echo ""
    echo -e "${CYAN}Creating swarm window...${NC}"
    create_swarm_window "$SESSION_NAME" "$WORKER_COUNT" "$PROJECT_DIR"

    # Initialize workers with task assignments
    echo -e "${CYAN}Initializing workers...${NC}"
    init_swarm_workers "$SESSION_NAME" "$WORKER_COUNT" "$PROJECT_DIR" "$TASK_IDS"

    echo ""
    echo -e "${GREEN}Swarm started!${NC}"
    echo ""
    echo -e "${CYAN}Keybindings:${NC}"
    echo "  Ctrl-b + 2       Switch to swarm window"
    echo "  Ctrl-b + arrows  Navigate panes"
    echo "  Ctrl-b + z       Zoom pane"
    echo ""
    echo -e "${CYAN}Commands:${NC}"
    echo "  vamp swarm --status   Check progress"
    echo "  vamp swarm --finish   Merge and cleanup"
    echo ""

    # Switch to swarm window and attach
    tmux select-window -t "$SESSION_NAME:swarm"
    tmux attach-session -t "$SESSION_NAME"
}

# ============================================
# Main entry point
# ============================================

case "${1:-}" in
    help|--help|-h)
        show_help
        ;;
    list|ls)
        list_sessions
        ;;
    attach|a)
        attach_session "$2"
        ;;
    kill|k)
        kill_session "$2"
        ;;
    killall)
        kill_all_sessions
        ;;
    init)
        init_project
        ;;
    setup)
        setup_beads
        ;;
    swarm)
        shift
        start_swarm "$@"
        ;;
    version|--version|-v)
        echo "vamp v${VAMP_VERSION}"
        ;;
    *)
        start_session "$1"
        ;;
esac
